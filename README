greasy.js - a dependancy framework for JavaScript

Rational


As a JavaScript application becomes more complicated, you can be faced with the challenge of a huge file. greasy.js aims to mitigate this by encouraging you to separate your application into separate components and allowing them to be dependent on other components.

Include greasy using the following

<script src=”greasy.js”></script>

Create a greasy object:
var greasy = new Greasy();

- or -

var greasy = Greasy.create();

Register your components with greasy

greasy.registerComponents(object);

Where object is a mapping of component-names to filenames. Eg:

greasy.registerComponents({
	“Mammal”: “Mammel.js”,
	“Human”: “Human.js”
});

When a component is requires, it will load the js file attributed to it.

We define a component:

greasy.defineComponent(options, prototype);

options is an object which may have any of the following:
name - the name of the class
requireClasses - array of other classnames that will be required
requireTemplates - array of templates that will be required
extend - a class that the class should extend on


prototype is an object descripting the 

greasy.defineClass({
	name: “Mammal”
	


Example use:

window.animalLibrary = (function ($, Greasy) {
	“use strict”;
	var greasy = Greasy.create();
greasy.registerComponents({
	“Mammal”: “Mammel.js”,
	“Human”: “Human.js”,
	“Thumb”: “Thumb.js”
});

greasy.setImports({
	$: $
});

$(document).ready(function () {
	greasy.requireComponents
});

return {
	greasy: greasy
};
}(jQuery, Greasy));

Mammel.js
window.animalLibrary.greasy.defineComponent(
	“Mammal”,
	function (imports) {
		“use strict”;
		var $ = imports.$;
		return {
			hasSpine: function () {
				return true;
			},
			greeting: function () {
				return “Not sure...”;
			},
			draw: function () {
				$(“.animal”).html(“Mammal”);
			}
		};
}
);

Thumb.js
window.animalLibrary.greasy.defineComponent(
	“Thumb”,
	function (imports) {
		“use strict”;
		var name = “”;
		return {
			initialize: function (options) {
				name = options.name || “Unnamed Thumb”;
			},
			greeting: function () {
				return name + “ says hello!”;
			}
};
}
);

Human.js
window.animalLibrary.greasy.defineComponent(
	“Human”,
	{
		require: “Thumb”,
		extend: “Mammel”
	},
	function (imports) {
		“use strict”;
		var $ = imports.$,
greasy = imports.greasy,
Thumb = greasy.get(“Thumb”),
thumb1 = Thumb.create({ name: “Thumb 1” }),
thumb2 = Thumb.create({ name: “Thumb 2” });
		return {
			greeting: function () {
				return “Hello World!<br />” + thumb1.greeting +
“<br />” + thumb2.greeting;
			},
			draw: function () {
				$(“.animal”).html(“Human”);
			}
		};
	}
);

Dependancies
jQuery
Underscore


Further Reading
Module pattern: http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth



Global variables
Global variables are bad (Crockford), but unfortunately the design of JavaScript gives us no choice but to use them. There are a variety of ways that we can mitigate this, one of which by using a module pattern, which involves containing you program within a single self-executing closure:

(function ($) {
	var hiddenFunction = function () {
		$(“.first-name”).text(“Bob”);
		$(“.last-name”).text(“Murray”);
	};
	hiddenFunction();
}(jQuery));

The closure allows the state of the module to be hidden and mitigates our need for global variables.

If we want our module to be accessible from outside, we must unfortunately assign this to a global variable.

window.myModule = (function ($) {
	var hiddenFunction = function () { /* Do stuff */ };
	var visibleFunction = function () { /* Do stuff */ };
	
	return {
		visibleFunction: visibleFunction
	};
}(jQuery));
window.myModule.visibleFunction();
